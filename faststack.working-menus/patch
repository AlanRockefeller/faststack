--- /dev/null
+++ b/faststack/imaging/editor.py
@@ -0,0 +1,141 @@
+import os
+import shutil
+import glob
+from pathlib import Path
+from typing import Optional, Dict, Any, Tuple
+from PIL import Image, ImageEnhance
+from io import BytesIO
+
+# Aspect Ratios for cropping
+INSTAGRAM_RATIOS = {
+    "Freeform": None,
+    "1:1 (Square)": (1, 1),
+    "4:5 (Portrait)": (4, 5),
+    "1.91:1 (Landscape)": (191, 100),
+    "9:16 (Story)": (9, 16),
+}
+
+class ImageEditor:
+    """Handles core image manipulation using PIL."""
+    def __init__(self):
+        # Stores the currently loaded PIL Image object (original)
+        self.original_image: Optional[Image.Image] = None
+        # Stores the currently applied edits (used for preview)
+        self.current_edits: Dict[str, Any] = self._initial_edits()
+        self.current_filepath: Optional[Path] = None
+
+    def _initial_edits(self) -> Dict[str, Any]:
+        return {
+            'brightness': 0.0,
+            'contrast': 0.0,
+            'saturation': 0.0,
+            'white_balance_by': 0.0, # Blue/Yellow (Cool/Warm)
+            'white_balance_mg': 0.0, # Magenta/Green (Tint)
+            'crop_box': None, # (left, top, right, bottom) normalized to 0-1000
+        }
+
+    def load_image(self, filepath: str):
+        """Load a new image for editing."""
+        if not filepath or not Path(filepath).exists():
+            self.original_image = None
+            self.current_filepath = None
+            return False
+        
+        self.current_filepath = Path(filepath)
+        # Reset edits
+        self.current_edits = self._initial_edits()
+        
+        try:
+            # We must load and close the original file handle immediately
+            self.original_image = Image.open(self.current_filepath).convert("RGB")
+            return True
+        except Exception as e:
+            print(f"Error loading image for editing: {e}")
+            self.original_image = None
+            return False
+
+    def _apply_edits(self, img: Image.Image) -> Image.Image:
+        """Applies all current edits to the provided PIL Image."""
+
+        # 1. Cropping (if defined)
+        crop_box = self.current_edits.get('crop_box')
+        if crop_box:
+            # Denormalize crop_box (0-1000) to actual pixel values
+            width, height = img.size
+            left = int(crop_box[0] * width / 1000)
+            top = int(crop_box[1] * height / 1000)
+            right = int(crop_box[2] * width / 1000)
+            bottom = int(crop_box[3] * height / 1000)
+            img = img.crop((left, top, right, bottom))
+        
+        # 2. Brightness (normalized -1.0 to 1.0 -> factor 0.0 to 2.0)
+        bright_factor = 1.0 + self.current_edits['brightness']
+        img = ImageEnhance.Brightness(img).enhance(bright_factor)
+
+        # 3. Contrast (normalized -1.0 to 1.0 -> factor 0.0 to 2.0)
+        contrast_factor = 1.0 + self.current_edits['contrast']
+        img = ImageEnhance.Contrast(img).enhance(contrast_factor)
+
+        # 4. Saturation (normalized -1.0 to 1.0 -> factor 0.0 to 2.0)
+        saturation_factor = 1.0 + self.current_edits['saturation']
+        img = ImageEnhance.Color(img).enhance(saturation_factor)
+
+        # 5. White Balance (Tint - simplistic color matrix manipulation)
+        by_val = self.current_edits['white_balance_by'] * 0.5 # -0.5 to 0.5
+        mg_val = self.current_edits['white_balance_mg'] * 0.5 # -0.5 to 0.5
+        
+        r, g, b = img.split()
+        
+        # Blue/Yellow adjustment
+        r_by_adjust = r.point(lambda i: i + by_val * 255)
+        g_by_adjust = g.point(lambda i: i + by_val * 255)
+        b_by_adjust = b.point(lambda i: i - by_val * 255)
+        
+        # Magenta/Green adjustment
+        r_mg_adjust = r_by_adjust.point(lambda i: i + mg_val * 255)
+        g_mg_adjust = g_by_adjust.point(lambda i: i - mg_val * 255)
+        b_mg_adjust = b_by_adjust.point(lambda i: i + mg_val * 255)
+        
+        return Image.merge("RGB", (r_mg_adjust, g_mg_adjust, b_mg_adjust))
+
+
+    def get_preview_data(self) -> Optional[bytes]:
+        """Apply current edits to the image and return the data as PNG bytes."""
+        if self.original_image is None:
+            return None
+
+        img = self.original_image.copy()
+        img = self._apply_edits(img)
+
+        # Convert the PIL image to bytes (PNG to avoid repeated lossy compression during preview)
+        byte_arr = BytesIO()
+        img.save(byte_arr, format='PNG') 
+        return byte_arr.getvalue()
+
+
+    def set_edit_param(self, key: str, value: float) -> bool:
+        """Update a single edit parameter (normalized -1.0 to 1.0)."""
+        if key in self.current_edits and key != 'crop_box':
+            self.current_edits[key] = value
+            return True
+        return False
+    
+    def set_crop_box(self, crop_box: Tuple[int, int, int, int]):
+        """Set the normalized crop box (left, top, right, bottom) from 0-1000."""
+        self.current_edits['crop_box'] = crop_box
+
+    def save_image(self) -> Optional[Path]:
+        """Saves the edited image, backing up the original."""
+        if self.original_image is None or self.current_filepath is None:
+            return None
+
+        final_img = self.original_image.copy()
+        final_img = self._apply_edits(final_img)
+
+        original_path = self.current_filepath
+        backup_path_base = original_path.parent / (original_path.stem + "-backup")
+        backup_path = backup_path_base.with_suffix(".jpg")
+        
+        i = 1
+        while backup_path.exists():
+            backup_path = backup_path_base.with_suffix(f"#{i}.jpg")
+            i += 1
+        
+        try:
+            # Perform the backup and overwrite
+            shutil.copy2(original_path, backup_path)
+            final_img.save(original_path, format='JPEG', quality=95) # Save as high-quality JPEG
+            return original_path
+        except Exception as e:
+            print(f"Failed to save edited image or backup: {e}")
+            return None
+
+# Dictionary of ratios for QML dropdown
+ASPECT_RATIOS = [{"name": name, "ratio": ratio} for name, ratio in INSTAGRAM_RATIOS.items()]
+```
--- /dev/null
+++ b/qml/ImageEditorDialog.qml
@@ -0,0 +1,105 @@
+import QtQuick 2.15
+import QtQuick.Controls 2.15
+import QtQuick.Layouts 1.15
+
+// Draggable popup dialog for image editing controls
Pane {
+    id: editDialog
+    // Use fixed size for simplicity in a draggable panel
+    width: 300
+    height: 500
+    
+    // Initial position - centered, slightly high
+    x: (parent.width - width) / 2
+    y: parent.height * 0.1
+    
+    // Draggable behavior (Title Bar)
+    MouseArea {
+        id: titleBar
+        anchors.top: parent.top
+        anchors.left: parent.left
+        anchors.right: parent.right
+        height: 30
+        acceptedButtons: Qt.LeftButton
+        
+        Rectangle {
+            anchors.fill: parent
+            color: uiState.theme === 1 ? "#333333" : "#DDDDDD"
+            border.color: "black"
+            border.width: 1
+            Text {
+                anchors.centerIn: parent
+                text: "Image Editor"
+                color: uiState.theme === 1 ? "white" : "black"
+                font.bold: true
+            }
+        }
+        
+        property point dragPoint: Qt.point(0,0)
+        
+        onPressed: { dragPoint = Qt.point(mouse.x, mouse.y) }
+        onPositionChanged: {
+            editDialog.x += mouse.x - dragPoint.x
+            editDialog.y += mouse.y - dragPoint.y
+        }
+    }
+
+    ColumnLayout {
+        anchors.top: titleBar.bottom
+        anchors.left: parent.left
+        anchors.right: parent.right
+        spacing: 10
+        padding: 10
+
+        // Helper component for Sliders
+        Component {
+            id: editSlider
+            ColumnLayout {
+                Text {
+                    text: modelData.name + ": " + (modelData.value * 100).toFixed(0)
+                    color: uiState.theme === 1 ? "white" : "black"
+                    font.pixelSize: 14
+                }
+                Slider {
+                    id: slider
+                    Layout.fillWidth: true
+                    from: -100
+                    to: 100
+                    stepSize: 1
+                    value: modelData.value * 100
+                    onValueChanged: {
+                        // Normalize back to -1.0 to 1.0 for Python logic
+                        appModel.app_controller.set_edit_parameter(modelData.key, slider.value / 100.0)
+                    }
+                }
+            }
+        }
+
+        // Sliders List
+        Repeater {
+            model: [
+                { name: "Brightness", key: "brightness", value: appModel.brightness },
+                { name: "Contrast", key: "contrast", value: appModel.contrast },
+                { name: "Saturation", key: "saturation", value: appModel.saturation },
+                { name: "White Balance (B/Y)", key: "white_balance_by", value: appModel.whiteBalanceBY },
+                { name: "White Balance (M/G)", key: "white_balance_mg", value: appModel.whiteBalanceMG }
+            ]
+            delegate: editSlider
+        }
+
+        // Crop Controls
+        RowLayout {
+            Layout.fillWidth: true
+            spacing: 5
+
+            Button {
+                id: cropButton
+                text: appModel.isCropping ? "Cropping (Click/Drag)" : "Crop"
+                Layout.fillWidth: true
+                onClicked: { appModel.isCropping = !appModel.isCropping }
+            }
+
+            ComboBox {
+                id: aspectRatioDropdown
+                Layout.preferredWidth: 100
+                model: appModel.aspectRatioNames
+                currentIndex: appModel.currentAspectRatioIndex
+                onCurrentIndexChanged: { appModel.currentAspectRatioIndex = currentIndex }
+                // NOTE: Aspect ratio locking logic is not fully implemented in this patch
+                // due to complexity, but the model property is available for future use.
+            }
+        }
+        
+        Text {
+            Layout.fillWidth: true
+            wrapMode: Text.WordWrap
+            text: appModel.isCropping ? "Click/Drag to select crop area. Press ENTER to execute crop." : ""
+            color: "red"
+            horizontalAlignment: Text.AlignHCenter
+            font.pixelSize: 12
+        }
+        
+        Button {
+            text: "Reset All Edits"
+            Layout.fillWidth: true
+            onClicked: { appModel.reset_edit_parameters() }
+        }
+    }
+}
```
--- a/app.py
+++ b/app.py
@@ -52,12 +52,24 @@
 
         # --------------------------------------------------------------------------
         # Image Provider Setup
-        self.image_provider = ImageProvider(self.app_controller.app_state_model)
+        # Use a single provider for both original and edited images
+        self.image_provider = ImageProvider(self.app_controller.app_state_model, is_edited_provider=False)
         self.engine.addImageProvider("imageProvider", self.image_provider)
+        
+        # Separate provider for the live-edited image preview
+        self.edited_image_provider = ImageProvider(self.app_controller.app_state_model, is_edited_provider=True)
+        self.engine.addImageProvider("editedImageProvider", self.edited_image_provider)
         
         # --------------------------------------------------------------------------
         # Engine Context Setup
         self.engine.rootContext().setContextProperty("appModel", self.app_controller.app_state_model)
+        
+        # --------------------------------------------------------------------------
+        # Connect signals for edit mode to manage image source
+        self.app_controller.app_state_model.isEditingChanged.connect(self._handle_editing_toggle)
+        # Connect data change signal to the edited provider
+        self.app_controller.app_state_model.currentEditedImageDataChanged.connect(
+            lambda: self.edited_image_provider.image_data = self.app_controller.app_state_model.current_edited_image_data
+        )
 
         # Load the QML file
         qml_file = Path(__file__).parent / "qml" / "main.qml"
@@ -74,6 +86,14 @@
         if self.engine.rootObjects():
             self.engine.rootObjects()[0].show()
 
+    def _handle_editing_toggle(self):
+        """Update the image provider source when editing mode changes."""
+        is_editing = self.app_controller.app_state_model.is_editing
+        
+        # If starting edit mode, ensure the initial edited data is generated
+        if is_editing:
+            # Trigger the edited image data update to show the initial (unmodified) preview
+            self.app_controller.app_state_model.current_edited_image_data = self.app_controller.image_editor.get_preview_data()
 
 def main():
     """Main function for FastStack."""
--- a/app_controller.py
+++ b/app_controller.py
@@ -10,6 +10,7 @@
 from faststack.io.indexer import find_images
 from faststack.io.sidecar import SidecarManager
 from faststack.imaging.prefetch import Prefetcher
+from faststack.imaging.editor import ImageEditor, ASPECT_RATIOS
 
 # Set up logger
 logger = logging.getLogger(__name__)
@@ -23,6 +24,7 @@
         self.prefetcher = Prefetcher(self)
         self.sidecar_manager = SidecarManager(self)
         self.app_state_model = AppStateModel(self)
+        self.image_editor = ImageEditor()
 
         # Load initial directory
         self.set_current_directory(config.get("default_directory", str(Path.home())))
@@ -118,6 +120,53 @@
             self.prefetcher.start_prefetch(self.current_image_index)
 
         self.app_state_model.current_image_file = current_image
+        # Load the image into the editor instance
+        self.image_editor.load_image(current_image.path if current_image else "")
+        self.app_state_model.reset_edit_parameters() # Reset edits for new image
+        
+    @Slot(result=QVariant)
+    def get_aspect_ratios(self) -> List[Dict[str, Any]]:
+        """Returns the list of aspect ratio names/values."""
+        return ASPECT_RATIOS
+
+    @Slot(str, float)
+    def set_edit_parameter(self, key: str, value: float):
+        """Sets a single editing parameter (brightness, saturation, etc.) and updates preview."""
+        if self.image_editor.set_edit_param(key, value):
+            # Trigger image provider to update the current image with preview data
+            self.app_state_model.current_edited_image_data = self.image_editor.get_preview_data()
+            self.app_state_model.edits_pending = True
+            # Manually update the model property to keep QML sliders synced
+            if key == 'brightness': self.app_state_model.brightness = value
+            elif key == 'contrast': self.app_state_model.contrast = value
+            elif key == 'saturation': self.app_state_model.saturation = value
+            elif key == 'white_balance_by': self.app_state_model.whiteBalanceBY = value
+            elif key == 'white_balance_mg': self.app_state_model.whiteBalanceMG = value
+
+    @Slot(float, float, float, float)
+    def set_crop_selection_normalized(self, x1, y1, x2, y2):
+        """Sets the normalized crop box (0-1) which is scaled to (0-1000) for Python logic."""
+        # Python logic expects normalized 0-1000
+        crop_box = (int(x1*1000), int(y1*1000), int(x2*1000), int(y2*1000))
+        self.image_editor.set_crop_box(crop_box)
+        # Update preview
+        self.app_state_model.current_edited_image_data = self.image_editor.get_preview_data()
+        self.app_state_model.edits_pending = True
+
+    @Slot()
+    def execute_crop(self):
+        """Executes the crop selection and disables cropping mode."""
+        self.app_state_model.isCropping = False
+        self.app_state_model.hasActiveCropSelection = False
+
+    @Slot(bool)
+    def save_or_discard_edits(self, save_changes: bool):
+        """Handles saving or discarding changes when edit mode is exited."""
+        if save_changes and self.app_state_model.edits_pending:
+            saved_path = self.image_editor.save_image()
+            if saved_path:
+                self.reload_current_image() # Reload to show the newly saved file
+        
+        # Always reset internal state and clear edited preview data
+        self.app_state_model.current_edited_image_data = None
+        self.app_state_model.reset_edit_parameters()
 
     @Slot(result=bool)
     def is_currently_staring(self):
--- a/app_state_model.py
+++ b/app_state_model.py
@@ -2,7 +2,7 @@
 import logging
 from pathlib import Path
 from typing import TYPE_CHECKING, Optional, List, Any
-from PySide6.QtCore import QObject, Signal, Slot, Property, QUrl
+from PySide6.QtCore import QObject, Signal, Slot, Property, QUrl, QByteArray, QVariant
 
 if TYPE_CHECKING:
     from .app_controller import AppController
@@ -37,6 +37,7 @@
     # Image editing properties
     isEditingChanged = Signal()
     isCroppingChanged = Signal()
+    editsPendingChanged = Signal()
     
     brightnessChanged = Signal()
     contrastChanged = Signal()
@@ -47,7 +48,7 @@
     
     hasActiveCropSelectionChanged = Signal()
     
-    # --- New signals for image editing ---
+    currentEditedImageDataChanged = Signal()
     
     aspectRatioNamesChanged = Signal()
     currentAspectRatioIndexChanged = Signal()
@@ -62,6 +63,16 @@
         self._is_editing = False
         self._is_cropping = False
 
+        # Editing parameters (normalized to -1.0 to 1.0)
+        self._edits_pending = False
+        self._brightness = 0.0
+        self._contrast = 0.0
+        self._saturation = 0.0
+        self._white_balance_by = 0.0
+        self._white_balance_mg = 0.0
+        self._has_active_crop_selection = False
+        self._current_edited_image_data = None # Holds image data bytes for QML provider
+        self._current_aspect_ratio_index = 0
+        self._aspect_ratio_names = [r["name"] for r in self.app_controller.get_aspect_ratios()]
+
     @Property(str, notify=currentImagePathChanged)
     def current_image_path(self):
         return str(self._current_image_file.path) if self._current_image_file else ""
@@ -176,3 +187,94 @@
         if self._is_cropping != value:
             self._is_cropping = value
             self.isCroppingChanged.emit()
+
+    @Property(bool, notify=editsPendingChanged)
+    def edits_pending(self):
+        return self._edits_pending
+
+    @edits_pending.setter
+    def edits_pending(self, value: bool):
+        if self._edits_pending != value:
+            self._edits_pending = value
+            self.editsPendingChanged.emit()
+
+    @Property(float, notify=brightnessChanged)
+    def brightness(self):
+        return self._brightness
+
+    @brightness.setter
+    def brightness(self, value: float):
+        if self._brightness != value:
+            self._brightness = value
+            self.brightnessChanged.emit()
+
+    @Property(float, notify=contrastChanged)
+    def contrast(self):
+        return self._contrast
+
+    @contrast.setter
+    def contrast(self, value: float):
+        if self._contrast != value:
+            self._contrast = value
+            self.contrastChanged.emit()
+
+    @Property(float, notify=saturationChanged)
+    def saturation(self):
+        return self._saturation
+
+    @saturation.setter
+    def saturation(self, value: float):
+        if self._saturation != value:
+            self._saturation = value
+            self.saturationChanged.emit()
+
+    @Property(float, notify=whiteBalanceBYChanged)
+    def whiteBalanceBY(self):
+        return self._white_balance_by
+
+    @whiteBalanceBY.setter
+    def whiteBalanceBY(self, value: float):
+        if self._white_balance_by != value:
+            self._white_balance_by = value
+            self.whiteBalanceBYChanged.emit()
+
+    @Property(float, notify=whiteBalanceMGChanged)
+    def whiteBalanceMG(self):
+        return self._white_balance_mg
+
+    @whiteBalanceMG.setter
+    def whiteBalanceMG(self, value: float):
+        if self._white_balance_mg != value:
+            self._white_balance_mg = value
+            self.whiteBalanceMGChanged.emit()
+
+    @Property(bool, notify=hasActiveCropSelectionChanged)
+    def hasActiveCropSelection(self):
+        return self._has_active_crop_selection
+
+    @hasActiveCropSelection.setter
+    def hasActiveCropSelection(self, value: bool):
+        if self._has_active_crop_selection != value:
+            self._has_active_crop_selection = value
+            self.hasActiveCropSelectionChanged.emit()
+
+    @Property(QByteArray, notify=currentEditedImageDataChanged)
+    def current_edited_image_data(self):
+        return self._current_edited_image_data
+
+    @current_edited_image_data.setter
+    def current_edited_image_data(self, value: Optional[bytes]):
+        data = QByteArray(value) if value is not None else QByteArray()
+        if self._current_edited_image_data != data:
+            self._current_edited_image_data = data
+            self.currentEditedImageDataChanged.emit()
+
+    @Property("QStringList", notify=aspectRatioNamesChanged)
+    def aspectRatioNames(self):
+        return self._aspect_ratio_names
+
+    @Property(int, notify=currentAspectRatioIndexChanged)
+    def currentAspectRatioIndex(self):
+        return self._current_aspect_ratio_index
+
+    @currentAspectRatioIndex.setter
+    def currentAspectRatioIndex(self, value: int):
+        if self._current_aspect_ratio_index != value:
+            self._current_aspect_ratio_index = value
+            self.currentAspectRatioIndexChanged.emit()
+
+    @Slot()
+    def reset_edit_parameters(self):
+        self.brightness = self.contrast = self.saturation = 0.0
+        self.whiteBalanceBY = self.whiteBalanceMG = 0.0
+        self.edits_pending = False
+        self.isCropping = False
+        self.hasActiveCropSelection = False
--- a/faststack/ui/provider.py
+++ b/faststack/ui/provider.py
@@ -10,13 +10,18 @@
 class ImageProvider(QQuickImageProvider):
     """Custom image provider for QML to retrieve images from the cache/disk."""
 
-    def __init__(self, app_state_model: "AppStateModel"):
+    def __init__(self, app_state_model: "AppStateModel", is_edited_provider: bool):
         super().__init__(QQuickImageProvider.Pixmap)
         self.app_state_model = app_state_model
         self.app_controller = self.app_state_model.app_controller
+        self.is_edited_provider = is_edited_provider
         self.current_path: Optional[Path] = None
         self.current_data: Optional[DecodedImage] = None
         self.last_load_time: float = 0
+        
+        # For edited provider, we store the raw byte data
+        self.image_data: QByteArray = QByteArray()
+        self.edited_pixmap: QPixmap = QPixmap()
 
     def requestPixmap(self, id: str, size: QSize):
         """
@@ -25,7 +30,8 @@
         :param size: The requested size of the image.
         :return: A QPixmap containing the image.
         """
-        if id.startswith("thumb_"):
+        # If this is the edited provider, serve the in-memory edited data
+        if self.is_edited_provider and not self.image_data.isEmpty():
+            self.edited_pixmap.loadFromData(self.image_data, "PNG")
+            # Scale the pixmap to the requested size
+            return self.edited_pixmap.scaled(size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
+
+        elif id.startswith("thumb_"):
             # Handle thumbnail request (existing logic)
             path_str = id.replace("thumb_", "", 1)
             path = Path(path_str)
--- a/qml/main.qml
+++ b/qml/main.qml
@@ -7,6 +7,8 @@
 import QtQuick.Controls 2.15
 import QtQuick.Layouts 1.15
 
+ImageEditorDialog { id: editorDialog; visible: appModel.isEditing }
+
 
 ApplicationWindow {
     id: applicationWindow
@@ -37,13 +39,21 @@
         
         // 'E' to toggle Edit Mode
         else if (event.key === Qt.Key_E) {
-            appModel.isEditing = !appModel.isEditing
+            if (appModel.isEditing) {
+                // If exiting, ask to save if changes are pending
+                if (appModel.edits_pending) {
+                    saveDiscardDialog.open()
+                } else {
+                    // No changes, just close
+                    appModel.isEditing = false
+                }
+            } else {
+                // Entering edit mode
+                appModel.isEditing = true
+            }
             event.accepted = true
         }
-    }
-
-
+        
+        // ENTER to execute crop in crop mode or confirm save/discard
+        else if (event.key === Qt.Key_Return || event.key === Qt.Key_Enter) {
+            if (appModel.isEditing && appModel.isCropping && imageMouseArea.selectionActive) {
+                appModel.app_controller.execute_crop()
+                // The crop is now "applied" (set in the model) and cropping selection ends
+                event.accepted = true
+            } else if (saveDiscardDialog.visible) {
+                saveDiscardDialog.handleClose(true) // Default to Yes
+                saveDiscardDialog.close()
+                event.accepted = true
+            }
+        }
+
+    }
     
     // Main Content Area
     RowLayout {
@@ -105,11 +115,14 @@
             sourceSize.width: mainImage.width
             sourceSize.height: mainImage.height
-            source: "image://imageProvider/" + appModel.current_image_path
+            
+            // Switch source based on edit mode
+            source: appModel.isEditing
+                    ? "image://editedImageProvider/currentEdit"
+                    : "image://imageProvider/" + appModel.current_image_path
             
             // Keep mouse wheel zoom working in edit mode
             MouseArea {
                 id: imageMouseArea
                 anchors.fill: parent
                 hoverEnabled: true
@@ -124,6 +137,39 @@
                 onWheel: {
                     imageMouseArea.forceActiveFocus()
                     applicationWindow.zoomImage(event.angleDelta.y)
                 }
+                
+                // Cropping selection logic
+                property bool selectionActive: false
+                property point startPoint: Qt.point(0, 0)
+                property point endPoint: Qt.point(0, 0)
+
+                onPressed: {
+                    if (appModel.isEditing && appModel.isCropping) {
+                        selectionActive = true
+                        startPoint = Qt.point(mouse.x, mouse.y)
+                        endPoint = startPoint
+                        appModel.hasActiveCropSelection = true
+                    }
+                }
+                onMouseMoved: {
+                    if (appModel.isEditing && appModel.isCropping && selectionActive) {
+                        endPoint = Qt.point(mouse.x, mouse.y)
+                    }
+                }
+                onReleased: {
+                    if (appModel.isEditing && appModel.isCropping && selectionActive) {
+                        // Send normalized coordinates to Python for preview update
+                        var rect = normalizeCrop(startPoint, endPoint)
+                        // Python expects normalized left, top, right, bottom from 0-1
+                        appModel.app_controller.set_crop_selection_normalized(rect.left, rect.top, rect.right, rect.bottom)
+                    }
+                }
+                
+                function normalizeCrop(p1, p2) {
+                    var left = Math.min(p1.x, p2.x) / mainImage.width
+                    var top = Math.min(p1.y, p2.y) / mainImage.height
+                    var right = Math.max(p1.x, p2.x) / mainImage.width
+                    var bottom = Math.max(p1.y, p2.y) / mainImage.height
+                    return { left: left, top: top, right: right, bottom: bottom }
+                }
+            }
+            
+            // Visual Cropping Overlay
+            Rectangle {
+                visible: appModel.isEditing && appModel.isCropping && imageMouseArea.selectionActive
+                x: Math.min(imageMouseArea.startPoint.x, imageMouseArea.endPoint.x)
+                y: Math.min(imageMouseArea.startPoint.y, imageMouseArea.endPoint.y)
+                width: Math.abs(imageMouseArea.startPoint.x - imageMouseArea.endPoint.x)
+                height: Math.abs(imageMouseArea.startPoint.y - imageMouseArea.endPoint.y)
+                color: "transparent"
+                border.color: "red"
+                border.width: 2
+                opacity: 0.8
             }
         }
 
@@ -133,3 +179,21 @@
             Layout.fillWidth: true
         }
     }
+    
+    // Save/Discard Confirmation Dialog
+    MessageDialog {
+        id: saveDiscardDialog
+        title: "Unsaved Edits"
+        text: "Do you want to save your image edits?"
+        
+        // Set default button to Yes (AcceptRole)
+        standardButtons: Dialog.Yes | Dialog.No
+        
+        // Helper function to handle saving/discarding and closing the editor
+        function handleClose(save: bool) {
+            appModel.app_controller.save_or_discard_edits(save)
+            appModel.isEditing = false // Close edit mode
+        }
+        
+        onAccepted: handleClose(true) // 'Yes' is the default/accepted action
+        onRejected: handleClose(false) // 'No' is the rejected action
+    }
 }
